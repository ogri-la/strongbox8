#!/bin/bash
set -eu

cmd=${1:-}

if test ! "$cmd"; then
    echo "command required"
    echo
    echo "available commands:"
    # alphabetical order
    echo "  build-all    build project from scratch"
    echo "  build        build project"
    echo "  clean        deletes all generated files"
    echo "  coverage     run tests, then show coverage report"
    echo "  fixtures     build/regenerate test fixtures"
    echo "  lint         run code linter"
    echo "  release      build project for distribution"
    echo "  test         run tests"
    echo "  update-deps  update project dependencies"
    exit 1
fi

shift
rest=$*

if test "$cmd" = ""; then
    exit 1

elif test "$cmd" = "build-all"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -a 'build all'
    # -v 'verbose'
    ./manage.sh clean
    go build \
        -C strongbox \
        -a \
        -v
    echo "wrote ./strongbox/strongbox"
    exit 0

elif test "$cmd" = "build"; then
    ./manage.sh clean
    # -C Change to dir before running the command.
    # -v 'verbose'
    go build \
        -C strongbox \
        -v
    echo "wrote ./strongbox/strongbox"
    exit 0

elif test "$cmd" = "clean"; then
    if [ ! -d "atk" ]; then
        git clone https://github.com/torkus/atk
    fi

    # files
    tbd=(
        "strongbox/linux-amd64" "strongbox/linux-amd64.sha256" # generated by 'release'
        "strongbox/strongbox" "strongbox/linux-amd64.sha256" # generated by 'build'
        "bw/coverage.out" "bw/coverage.html" "strongbox/coverage.out" "strongbox/coverage.html" # generated by 'coverage'
        "coverage" "coverage.html"
    )
    for fname in "${tbd[@]}"; do
        if [ -f "$fname" ]; then
            rm -f "$fname"
            echo "deleted file '$fname'"
        fi
    done

    # dirs
    tbd=(
        "strongbox/release" "squashfs-root" "release" "AppDir" # generated by 'release'
        "unit" # generated by 'coverage'
    )
    for dirname in "${tbd[@]}"; do
        if [ -d "$dirname" ]; then
            rm -rf "$dirname"
            echo "deleted directory '$dirname'"
        fi
    done
    exit 0

elif test "$cmd" = "coverage"; then
    mkdir -p ./unit
    # -cover 'enable coverage analysis'
    # -timeout=5s 'individual tests have 5s to complete'
    # -args -test.gocoverdir= 'write binary coverage data to this dir'
    go test -timeout=5s -cover ./strongbox/... -args -test.gocoverdir="$PWD/unit"
    go test -timeout=5s -cover ./bw/... -args -test.gocoverdir="$PWD/unit"
    # convert coverage data in 'unit' dir to a textual format
    go tool covdata textfmt -i=unit/ -o coverage
    # generate a html report from textual coverage data
    go tool cover -html=coverage -o coverage.html
    echo "wrote ./unit"
    echo "wrote ./coverage"
    echo "wrote ./coverage.html"
    exit 0

elif test "$cmd" = "fixtures"; then
    # generate zip files
    (
        cd strongbox/src/testdata/zipfiles
        rm -f ./*.zip
	# lol: https://stackoverflow.com/questions/3774278/extracting-a-7-zip-file-silently-command-line-option#answer-11629736
	# 'a' add files to archive
	# '-tzip' is '-t{Type}'
	# '-w' set cwd
        7z a -tzip everyaddon--1-2-3.zip -w everyaddon--1-2-3/. | grep 'ing archive'
        7z a -tzip everyaddon--1-2-4.zip -w everyaddon--1-2-4/. | grep 'ing archive'
        7z a -tzip everyaddon--7-8-9.zip -w everyaddon--7-8-9/. | grep 'ing archive'
    )
    exit 0

elif test "$cmd" = "lint"; then
    # go install github.com/mgechev/revive@latest
    revive --formatter json ./bw/... ./strongbox/...
    exit 0

elif test "$cmd" = "release"; then
    # generate binaries suitable for releasing to the public.
    # this should be done within a controlled environment like a container (see ./build-image.sh)

    ./manage.sh clean

    # fail when local dependencies are not 100% reflected remotely
    (
        cd ./atk
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        if [[ "$current_branch" != "master" ]]; then
          echo "ERROR: ./atk is not on the 'master' branch, refusing to release: $current_branch"
          exit 1
        fi

        if [[ -n $(git ls-files --others --exclude-standard) ]]; then
          echo "ERROR: ./atk has untracked files, refusing to release"
          exit 1
        fi

        if [[ -n $(git status --porcelain) ]]; then
          echo "ERROR: ./atk has uncommitted changes, refusing to release"
          exit 1
        fi

        if [[ -n $(git cherry -v) ]]; then
          echo "ERROR: ./atk has unpushed commits, refusing to release"
          exit 1
        fi
    )

    # warn when the releases generated may not be reproducible.
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ "$current_branch" != "master" ]]; then
      echo "WARNING: ./ is not on the 'master' branch: $current_branch"
    fi

    if [[ -n $(git ls-files --others --exclude-standard) ]]; then
      echo "WARNING: ./ has untracked files"
    fi

    if [[ -n $(git status --porcelain) ]]; then
      echo "WARNING: ./ has uncommitted changes"
    fi

    if [[ -n $(git cherry -v) ]]; then
      echo "WARNING: ./ has unpushed commits, refusing to release"
    fi

    # GOOS is 'Go OS' and is being explicit in which OS to build for.
    # ld -s is 'disable symbol table'
    # ld -w is 'disable DWARF generation'
    # -trimpath removes leading paths to source files
    # -v 'verbose'
    # -o 'output'

    platforms=("linux" "windows") # cannot target darwin without incorporating Xcode, which would violate GPL
    architectures=("arm64" "amd64")

    output_dir="release"
    mkdir -p "$output_dir"

    ldflags="-s -w"
    trimpath="-trimpath"
    cgo_enabled=1

    for GOOS in "${platforms[@]}"; do
      for GOARCH in "${architectures[@]}"; do
        binary_name="${GOOS}-${GOARCH}" # "linux-amd64", "windows-arm64"
        output_path="${output_dir}/${binary_name}" # "./release/linux-amd64"

        unset CC
        if [[ "$GOOS" == "linux" && "$GOARCH" == "arm64" ]]; then
          export CC=aarch64-linux-gnu-gcc

        elif [[ "$GOOS" == "windows" && "$GOARCH" == "amd64" ]]; then
          export CC=x86_64-w64-mingw32-gcc
          output_path+=".exe"

        elif [[ "$GOOS" == "windows" && "$GOARCH" == "arm64" ]]; then
          export CC=aarch64-w64-mingw32-gcc
          output_path+=".exe"

        fi

        export CGO_ENABLED=$cgo_enabled
        export GOOS=$GOOS
        export GOARCH=$GOARCH

        echo "Building for $GOOS/$GOARCH..."

        go build \
          -C strongbox \
          -ldflags="$ldflags" \
          $trimpath \
          -o "$output_path"
        sha256sum "strongbox/$output_path" > "strongbox/${output_path}.sha256"

        if [[ "$GOARCH" == "amd64" ]]; then
            (
                cd ./strongbox
                upx --best "$output_path" -o "${output_path}.upx"
                sha256sum "${output_path}.upx" > "${output_path}.upx.sha256"
            )
        fi

      done
    done

    rm -rf ./release
    mv ./strongbox/release ./
    ls -la ./release

    echo "done"
    exit 0

elif test "$cmd" = "test"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -v verbose
    # -timeout=5s 'individual tests have 5s to complete'
    (
        cd strongbox
        go test \
            -v \
            -timeout=5s \
            ./...
    )
    (
        cd bw
        go test \
            -v \
            -timeout=5s \
            ./...
    )
    exit 0


elif test "$cmd" = "update-deps"; then
    # -u 'update modules [...] to use newer minor or patch releases when available'
    (
        cd strongbox
        go get -u
        go mod tidy
    )
    (
        cd bw
        go get -u
        go mod tidy
    )
    ./manage.sh build
    exit 0

# ...

fi

echo "unknown command: $cmd"
exit 1
